name: "Factory: Integrator"

on:
  workflow_dispatch:
    inputs:
      spec:
        description: "Path to service spec YAML"
        required: true
        type: string
      phase:
        description: "Phase ID to integrate"
        required: true
        type: string
      prs:
        description: "Comma-separated PR numbers (in target repo)"
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write

concurrency:
  group: factory-integrator
  cancel-in-progress: false

jobs:
  integrate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.FACTORY_GH_PAT }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          npm install -g @anthropic-ai/claude-code
          pip install pyyaml

      - name: Read target repo and parent issue from spec
        id: target
        run: |
          TARGET_REPO=$(grep 'repo:' ${{ inputs.spec }} | head -1 | awk '{print $2}')
          echo "repo=${TARGET_REPO}" >> "$GITHUB_OUTPUT"

          # Read parent issue from progress file
          SERVICE=$(python3 -c "
          import yaml
          with open('${{ inputs.spec }}') as f:
              spec = yaml.safe_load(f)
          print(spec['service']['name'])
          ")
          echo "service=${SERVICE}" >> "$GITHUB_OUTPUT"

          PROGRESS_FILE="progress/${SERVICE}.progress.yaml"
          if [ -f "$PROGRESS_FILE" ]; then
            PARENT_ISSUE=$(python3 -c "
          import yaml
          with open('${PROGRESS_FILE}') as f:
              p = yaml.safe_load(f)
          print(p.get('parentIssue', ''))
          " 2>/dev/null || echo "")
            echo "parent_issue=${PARENT_ISSUE}" >> "$GITHUB_OUTPUT"
          else
            echo "parent_issue=" >> "$GITHUB_OUTPUT"
          fi

      - name: Clone target repo
        env:
          GH_TOKEN: ${{ secrets.FACTORY_GH_PAT }}
        run: |
          gh repo clone ${{ steps.target.outputs.repo }} /tmp/target-repo
          cd /tmp/target-repo
          git config user.name "Factory Bot"
          git config user.email "factory@molroo.io"

      - name: Integrator — Merge & Verify
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GH_TOKEN: ${{ secrets.FACTORY_GH_PAT }}
        run: |
          cd /tmp/target-repo

          claude -p "You are the Factory Integrator Agent.

          Target repo: ${{ steps.target.outputs.repo }} (cloned at current directory)
          Phase: ${{ inputs.phase }}
          Worker PRs to merge: ${{ inputs.prs }}

          Instructions:
          1. Create integration branch: integrate/${{ inputs.phase }}
          2. For each PR number in '${{ inputs.prs }}':
             - Get branch: gh pr view <num> --repo ${{ steps.target.outputs.repo }} --json headRefName -q .headRefName
             - git fetch origin && git merge --no-ff origin/<branch>
             - Resolve conflicts if any
          3. Run: npm install && npm run build (if package.json exists)
          4. Fix build issues if needed
          5. Push integration branch to target repo
          6. Create integration PR in target repo

          IMPORTANT: Do NOT update progress or trigger next phase. That will be handled automatically after you finish." \
            --output-format text \
            --max-turns 35 \
            --dangerously-skip-permissions

          CLAUDE_EXIT=$?
          if [ $CLAUDE_EXIT -ne 0 ]; then
            echo "::error::Claude Code exited with code $CLAUDE_EXIT"
            exit 1
          fi

      - name: Report integration failure
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.FACTORY_GH_PAT }}
        run: |
          PHASE="${{ inputs.phase }}"
          SPEC="${{ inputs.spec }}"
          PARENT_ISSUE="${{ steps.target.outputs.parent_issue }}"
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          gh label create "factory:blocked" --color D93F0B --force 2>/dev/null || true
          gh issue create \
            --title "[factory:blocked] Integration failed — Phase '${PHASE}'" \
            --label "factory:blocked" \
            --body "## Integration Failure

          **Phase:** ${PHASE}
          **Spec:** ${SPEC}
          **Worker PRs:** ${{ inputs.prs }}

          The Integrator agent failed to merge worker PRs for this phase.

          ### Possible causes
          - Merge conflicts between worker branches
          - Build failure after merge
          - Claude agent hit max-turns

          ### Recovery options
          1. Review the [run log](${RUN_URL})
          2. Fix issues manually in the target repo
          3. Re-trigger: \`gh workflow run factory-integrator.yml --field spec=\"${SPEC}\" --field phase=\"${PHASE}\" --field prs=\"${{ inputs.prs }}\"\`
          4. Or use the recovery workflow: \`gh workflow run factory-recover.yml --field spec=\"${SPEC}\" --field phase=\"${PHASE}\" --field action=\"retry-integration\"\`

          ---
          *This issue was auto-created by the Factory pipeline.*"

          # Notify parent issue
          if [ -n "$PARENT_ISSUE" ]; then
            gh issue comment "$PARENT_ISSUE" \
              --body "<!-- factory:bot -->
          Integration failed for phase **${PHASE}**. See [run log](${RUN_URL}).
          Recovery options available — check the blocked issue for details." 2>/dev/null || true
          fi

      - name: Update progress checklist on parent issue
        if: success()
        env:
          GH_TOKEN: ${{ secrets.FACTORY_GH_PAT }}
        run: |
          PHASE="${{ inputs.phase }}"
          SPEC="${{ inputs.spec }}"
          SERVICE="${{ steps.target.outputs.service }}"
          PARENT_ISSUE="${{ steps.target.outputs.parent_issue }}"

          if [ -z "$PARENT_ISSUE" ]; then
            echo "No parent issue to update."
            exit 0
          fi

          PROGRESS_FILE="progress/${SERVICE}.progress.yaml"

          # Build updated checklist from spec + progress
          CHECKLIST=$(python3 -c "
          import yaml

          with open('${SPEC}') as f:
              spec = yaml.safe_load(f)

          progress_data = {}
          try:
              with open('${PROGRESS_FILE}') as f:
                  progress_data = yaml.safe_load(f) or {}
          except:
              pass

          lines = []
          for phase_id, phase_spec in spec.get('phases', {}).items():
              desc = phase_spec.get('description', phase_id)
              tasks = phase_spec.get('tasks', [])
              task_count = len(tasks)
              phase_progress = progress_data.get('phases', {}).get(phase_id, {})
              status = phase_progress.get('status', 'pending')

              if status == 'completed':
                  lines.append(f'- [x] **{phase_id}** — {desc} ({task_count} tasks)')
              elif status == 'in_progress':
                  lines.append(f'- [ ] **{phase_id}** — {desc} ({task_count} tasks) \u2190 In progress')
              else:
                  lines.append(f'- [ ] **{phase_id}** — {desc} ({task_count} tasks)')

          print('\n'.join(lines))
          ")

          # Find existing progress comment and update it
          COMMENT_ID=$(gh api "repos/${{ github.repository }}/issues/${PARENT_ISSUE}/comments" \
            --jq '.[] | select(.body | contains("<!-- factory:progress -->")) | .id' | tail -1)

          BODY="<!-- factory:bot --><!-- factory:progress -->
          ## Pipeline Progress

          ${CHECKLIST}

          _Updated automatically as phases complete._"

          if [ -n "$COMMENT_ID" ]; then
            gh api "repos/${{ github.repository }}/issues/comments/${COMMENT_ID}" \
              -X PATCH -f body="${BODY}"
            echo "Updated existing progress comment #${COMMENT_ID}"
          else
            gh issue comment "$PARENT_ISSUE" --body "${BODY}"
            echo "Created new progress comment"
          fi

      - name: Merge integration PR & close worker PRs
        if: success()
        env:
          GH_TOKEN: ${{ secrets.FACTORY_GH_PAT }}
        run: |
          TARGET_REPO="${{ steps.target.outputs.repo }}"
          PHASE="${{ inputs.phase }}"
          WORKER_PRS="${{ inputs.prs }}"

          echo "=== Finding integration PR for phase '${PHASE}' ==="
          INTEGRATION_PR=$(gh pr list --repo "$TARGET_REPO" --state open --head "integrate/${PHASE}" --json number -q '.[0].number')

          if [ -n "$INTEGRATION_PR" ]; then
            echo "Merging integration PR #${INTEGRATION_PR} into main..."
            gh pr merge "$INTEGRATION_PR" --repo "$TARGET_REPO" --merge --delete-branch \
              --body "[factory:integrator] Phase '${PHASE}' integration merged automatically."
            echo "Integration PR #${INTEGRATION_PR} merged successfully."
          else
            echo "::warning::No open integration PR found for branch 'integrate/${PHASE}'"
          fi

          # Close worker PRs (superseded by integration merge)
          echo "=== Closing worker PRs: ${WORKER_PRS} ==="
          IFS=',' read -ra PR_ARRAY <<< "$WORKER_PRS"
          for PR_NUM in "${PR_ARRAY[@]}"; do
            PR_NUM=$(echo "$PR_NUM" | tr -d ' ')
            PR_STATE=$(gh pr view "$PR_NUM" --repo "$TARGET_REPO" --json state -q .state 2>/dev/null || echo "UNKNOWN")
            if [ "$PR_STATE" = "OPEN" ]; then
              gh pr close "$PR_NUM" --repo "$TARGET_REPO" --delete-branch \
                --comment "[factory:integrator] Superseded by integration PR #${INTEGRATION_PR}. Changes included in phase '${PHASE}' merge."
              echo "Closed worker PR #${PR_NUM}"
            else
              echo "Worker PR #${PR_NUM} already ${PR_STATE}, skipping."
            fi
          done

      - name: Update progress & trigger next phase
        if: success()
        env:
          GH_TOKEN: ${{ secrets.FACTORY_GH_PAT }}
        run: |
          PHASE="${{ inputs.phase }}"
          SPEC="${{ inputs.spec }}"
          SERVICE="${{ steps.target.outputs.service }}"
          PARENT_ISSUE="${{ steps.target.outputs.parent_issue }}"
          echo "Service: ${SERVICE}, Phase: ${PHASE}"

          PROGRESS_FILE="progress/${SERVICE}.progress.yaml"
          if [ ! -f "$PROGRESS_FILE" ]; then
            echo "::error::Progress file not found: ${PROGRESS_FILE}"
            exit 1
          fi

          # Update phase status to completed using Python
          python3 -c "
          import yaml

          with open('${PROGRESS_FILE}') as f:
              progress = yaml.safe_load(f)

          if '${PHASE}' in progress.get('phases', {}):
              progress['phases']['${PHASE}']['status'] = 'completed'
              for task_id, task in progress['phases']['${PHASE}'].get('tasks', {}).items():
                  if isinstance(task, dict):
                      task['status'] = 'completed'

          with open('${PROGRESS_FILE}', 'w') as f:
              yaml.dump(progress, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
          "

          # Close worker issues for this phase
          ISSUE_NUMBERS=$(gh issue list --label "factory:worker-task" --state open --json number -q '.[].number')
          for ISSUE_NUM in $ISSUE_NUMBERS; do
            BODY=$(gh issue view "$ISSUE_NUM" --json body -q .body)
            ISSUE_PHASE=$(echo "$BODY" | grep -iP '\*\*Phase\*?\*?:' | head -1 | sed 's/.*[*:]\s*//' | awk '{print $1}' | tr -d '`*')
            if [ "$ISSUE_PHASE" = "$PHASE" ]; then
              gh issue close "$ISSUE_NUM" --comment "[factory:integrator] Phase '${PHASE}' integrated. Closing."
            fi
          done

          # Commit and push progress update
          git config user.name "Factory Bot"
          git config user.email "factory@molroo.io"
          git add "$PROGRESS_FILE"
          git commit -m "chore(factory): mark ${PHASE} phase completed" || echo "No changes to commit"
          git push || echo "Push failed, may need rebase"

          # Phase completion is reflected in the progress checklist update step

          # Determine next phase
          NEXT_PHASE=$(python3 -c "
          import yaml

          with open('${SPEC}') as f:
              spec = yaml.safe_load(f)

          with open('${PROGRESS_FILE}') as f:
              progress = yaml.safe_load(f)

          phases = list(spec.get('phases', {}).keys())
          for phase_id in phases:
              phase_progress = progress.get('phases', {}).get(phase_id, {})
              if phase_progress.get('status') not in ('completed', 'in_progress'):
                  # Check dependencies
                  deps = spec['phases'][phase_id].get('dependsOn', [])
                  all_deps_done = all(
                      progress.get('phases', {}).get(d, {}).get('status') == 'completed'
                      for d in deps
                  )
                  if all_deps_done:
                      print(phase_id)
                      break
          ")

          if [ -n "$NEXT_PHASE" ]; then
            echo "=== Triggering Approve for next phase: ${NEXT_PHASE} ==="

            # Re-trigger approve workflow by re-using lead logic inline
            # Since factory-lead.yml is removed, we dispatch directly
            claude -p "You are the Factory Lead Agent. Your task:

            1. Read the service spec at '${SPEC}'
            2. Read the progress YAML at '${PROGRESS_FILE}'
            3. Focus on phase: ${NEXT_PHASE}

            4. For each task in the phase, create a GitHub Issue IN THIS REPO with label 'factory:worker-task'
               Use 'gh label create factory:worker-task --color FF6B35 --force' first.

               Each issue body MUST follow this format:
               ---
               ## Factory Worker Task: <task-id>

               **Target Repo:** ${{ steps.target.outputs.repo }}
               **Phase:** ${NEXT_PHASE}
               **Spec:** ${SPEC}
               **Branch:** factory/<task-id>
               **Parent Issue:** #${PARENT_ISSUE}
               **Task Type:** <CREATE or MODIFY>

               ### File Ownership
               <list of files>

               ### Requirements
               <requirements from spec>

               ### Reference
               Read factory/CLAUDE.md for SDK patterns and tech stack requirements.

               ---
               *This is a factory-generated task.*
               ---

            5. Update progress YAML: set phase status to 'in_progress', each task to 'dispatched' with issue number
            6. Commit and push the progress update
            7. Post a summary comment on parent issue #${PARENT_ISSUE}" \
              --output-format text \
              --max-turns 25 \
              --dangerously-skip-permissions || echo "::warning::Next phase dispatch failed"
          else
            echo "=== All phases completed! ==="

            # Mark parent issue as completed
            if [ -n "$PARENT_ISSUE" ]; then
              gh label create "factory:completed" --color 0E8A16 --force 2>/dev/null || true
              gh issue edit "$PARENT_ISSUE" --remove-label "factory:executing" 2>/dev/null || true
              gh issue edit "$PARENT_ISSUE" --add-label "factory:completed"
              gh issue comment "$PARENT_ISSUE" \
                --body "<!-- factory:bot -->
          All phases completed! The service has been built and deployed.

          Check the progress file for deploy URL and final status." 2>/dev/null || true
              gh issue close "$PARENT_ISSUE" 2>/dev/null || true
            fi
          fi

      - name: Deploy to hosting platform
        if: success()
        env:
          GH_TOKEN: ${{ secrets.FACTORY_GH_PAT }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
        run: |
          SPEC="${{ inputs.spec }}"
          TARGET_REPO="${{ steps.target.outputs.repo }}"
          PARENT_ISSUE="${{ steps.target.outputs.parent_issue }}"

          # Determine deploy platform from spec
          PLATFORM=$(python3 -c "
          import yaml
          with open('${SPEC}') as f:
              spec = yaml.safe_load(f)
          deploy = spec.get('deploy', spec.get('stack', {}).get('deploy', 'none'))
          if isinstance(deploy, dict):
              print(deploy.get('platform', 'none'))
          else:
              print(deploy)
          ")

          echo "Deploy platform: ${PLATFORM}"

          if [ "$PLATFORM" = "none" ] || [ -z "$PLATFORM" ]; then
            echo "No deploy platform configured. Skipping."
            exit 0
          fi

          # Pull latest main from target repo
          cd /tmp/target-repo
          git checkout main 2>/dev/null || true
          git pull origin main 2>/dev/null || true

          case "$PLATFORM" in
            vercel)
              if [ -z "$VERCEL_TOKEN" ]; then
                echo "::warning::VERCEL_TOKEN not set. Skipping Vercel deploy."
                exit 0
              fi

              # Build on GitHub Actions (has PAT for private packages)
              npm install 2>&1 || true
              npm run build 2>&1 || true

              if [ ! -d "dist" ]; then
                echo "::warning::No dist/ directory after build. Skipping deploy."
                exit 0
              fi

              # Prepare pre-built static deploy directory
              DEPLOY_DIR="/tmp/vercel-deploy"
              rm -rf "$DEPLOY_DIR"
              mkdir -p "$DEPLOY_DIR"
              cp -r dist/* "$DEPLOY_DIR/"

              # vercel.json that skips build (already built)
              cat > "$DEPLOY_DIR/vercel.json" << 'VJSON'
          {
            "buildCommand": "",
            "outputDirectory": "."
          }
          VJSON

              # Determine Vercel project name from spec service name
              SERVICE_NAME="${{ steps.target.outputs.service }}"
              VERCEL_PROJECT="${SERVICE_NAME}-deploy"

              npm install -g vercel 2>/dev/null || true
              cd "$DEPLOY_DIR"

              # Link to existing project (or create new one)
              vercel link --yes --token "$VERCEL_TOKEN" --project "$VERCEL_PROJECT" 2>&1 || true

              # Deploy pre-built static files (no build on Vercel)
              DEPLOY_OUTPUT=$(vercel deploy --prod --yes --token "$VERCEL_TOKEN" 2>&1) || true
              DEPLOY_URL=$(echo "$DEPLOY_OUTPUT" | grep -oE 'https://[^ ]+\.vercel\.app' | tail -1)
              echo "Deploy output: $DEPLOY_OUTPUT"

              cd /tmp/target-repo
              ;;

            cloudflare-pages)
              npm run build 2>/dev/null || true
              DEPLOY_OUTPUT=$(npx wrangler pages deploy dist --project-name "$(basename $TARGET_REPO)" 2>&1) || true
              DEPLOY_URL=$(echo "$DEPLOY_OUTPUT" | grep -oE 'https://[^ ]+' | tail -1)
              ;;

            github-pages)
              mkdir -p .github/workflows
              cp "${{ github.workspace }}/templates/deploy/github-pages/deploy.yml" .github/workflows/deploy.yml
              git add .github/workflows/deploy.yml
              git commit -m "chore: add GitHub Pages deploy workflow" || true
              git push origin main || true
              ORG=$(echo "$TARGET_REPO" | cut -d'/' -f1)
              REPO=$(echo "$TARGET_REPO" | cut -d'/' -f2)
              DEPLOY_URL="https://${ORG}.github.io/${REPO}"
              ;;
          esac

          echo "DEPLOY_URL=${DEPLOY_URL}"

          if [ -n "$DEPLOY_URL" ]; then
            echo "=== Deployed: ${DEPLOY_URL} ==="

            # Update progress with deploy URL
            cd "${{ github.workspace }}"
            SERVICE="${{ steps.target.outputs.service }}"
            PROGRESS_FILE="progress/${SERVICE}.progress.yaml"

            python3 -c "
          import yaml

          with open('${PROGRESS_FILE}') as f:
              progress = yaml.safe_load(f)

          progress['deployUrl'] = '${DEPLOY_URL}'
          progress['deployPlatform'] = '${PLATFORM}'

          with open('${PROGRESS_FILE}', 'w') as f:
              yaml.dump(progress, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
            "
            git add "$PROGRESS_FILE"
            git commit -m "chore(factory): update deploy URL — ${DEPLOY_URL}" || true
            git push || true

            # Notify parent issue about deployment
            if [ -n "$PARENT_ISSUE" ]; then
              gh issue comment "$PARENT_ISSUE" \
                --body "<!-- factory:bot -->
          Deployed to ${PLATFORM}: ${DEPLOY_URL}" 2>/dev/null || true
            fi
          fi
